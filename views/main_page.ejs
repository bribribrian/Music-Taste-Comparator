
<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
  <link rel='stylesheet' href='/stylesheets/main_page.css' />
  <title>
    Music Taste Comparator
  </title>
</head>


<body>
        <h1>Music Taste Comparator</h1>
        
        <div id="trackinfo" class="trackinfo"></div>

        <form id="searchForm">
            <div>
                <p>Enter a username</p>
                  <input id='searchUser' type='text' value='keenannichols'></input>
            </div>
                <input type='submit'></input>
        </form>
        
        <div class='canvas'></div>
</body>
<!-- <script src="../API/spotify_api.js"></script> -->
<script>
    document.addEventListener("DOMContentLoaded", () => {
        const seachForm = document.getElementById("searchForm");
        seachForm.addEventListener("submit", handleSubmit);
    });
    
    function handleSubmit (e) {
        e.preventDefault();
        const searchUser = document.getElementById("searchUser");

        console.log(searchUser.value);
        fetchSearchedUser(searchUser.value);
    }

    function fetchSearchedUser(username) {
        const request = new XMLHttpRequest();
        request.open(
        "GET",
        `/searcheduser?username=${username}`,
        true
        );
        request.onload = this.ajaxSuccess.bind(request);
        request.send();
    }

    function ajaxSuccess() {
        if (this.status >= 200 && this.status < 400) {
        const data = JSON.parse(this.response);
        console.log(data);
        } else {
        // error
        }
    }

    
    // console.log(track_info);
    const trackAttributes = <%- JSON.stringify(tracks_audiodata) %>;
    const genreCollection = <%- JSON.stringify(genre_collection) %>;
    let htmlOutput = "<h1>Your tracks:</h1><ul>";
    console.log(trackAttributes);
    console.log(genreCollection);
    trackAttributes.forEach(trackInfo => {
        htmlOutput += `<li>${trackInfo.name}</li>`;
    });
    htmlOutput += "</ul>";
    // console.log(genreCollection);
    // document.getElementById("sessionData").innerHTML = `Your session data:
    // <br /> ${sessionData}`;
    // document.getElementById("trackinfo").innerHTML = function(trackAttriubutes) {
    //     trackAttributes.forEach(track => {
    //         return <div>track.title</div>
    //     }
    // )};
    
    document.getElementById("trackinfo").innerHTML = htmlOutput;
    //`Your tracks:
    // <br /> 
    // ${trackAttributes[0].title}`
    
    // const circleRadiusScale = d3.scaleSqrt()
    //     .domain(populationExtent)
    //     .range([circleSize.min, circleSize.max]);

    // const forces,
    //   forceSimulation;

    // d3.queue()
    // .defer(d3.csv, "genres")
    // .await(createBubbleChart);

    function createBubbleChart(genres_collection) {
        const counts = [];
        genres_collection.forEach(genre_obj => {
            counts.push(genre_obj.count);
        });

        const countExtent = d3.extent(counts);

        var genreColorScale = d3.scaleOrdinal(d3.schemeCategory10)
            .domain([0,1,2]);

        var width = 800,
            height = 800,
            clusterPadding = 1,
            padding = 1.5;
        var svg,
            circles,
            circleSize = { min: 10, max: 80 };
        var circleRadiusScale = d3.scaleSqrt()
            .domain(countExtent)
            .range([circleSize.min, circleSize.max]);
        var forces,
            forceSimulation;

        createSVG();
        createCircles();
        createForces();
        createForceSimulation();
    
        function createSVG() {
        svg = d3.select(".canvas")
        .append("svg")
            .attr("width", width)
            .attr("height", height);
        }

        function createCircles() {
            var formatCount = d3.format(",");
            circles = svg.selectAll("circle")
                .data(genreCollection)
                .enter()
                    .append("circle")
                    .attr("r", function(g) { return circleRadiusScale(g.count); })
                    // .attr("cx", function(d) { 
                    //     debugger;
                    //     return d.count * 2; })
                    // .attr("cy", function(d) { return d.count; })
                    .on("mouseover", function(g) {
                        updateGenreInfo(g);
                    })
                    .on("mouseout", function(g) {
                        updateGenreInfo();
                    })
                    // .style("padding", 50);
            updateCircles();

            function updateGenreInfo(genre) {
                var info = "";
                    if (genre) {
                        info = [genre.genreName, formatCount(genre.count)].join(": ");
                    }
                d3.select("#genre-info").html(info);
                }
        }

        
        // function collide(alpha) {
        // var quadtree = d3.quadtree(circles);
        // return function(d) {
        //     var r = d.radius + circleSize.max + Math.max(padding, clusterPadding),
        //         nx1 = d.x - r,
        //         nx2 = d.x + r,
        //         ny1 = d.y - r,
        //         ny2 = d.y + r;
        //     quadtree.visit(function(quad, x1, y1, x2, y2) {
        //     if (quad.point && (quad.point !== d)) {
        //         var x = d.x - quad.point.x,
        //             y = d.y - quad.point.y,
        //             l = Math.sqrt(x * x + y * y),
        //             r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
        //         if (l < r) {
        //         l = (l - r) / l * alpha;
        //         d.x -= x *= l;
        //         d.y -= y *= l;
        //         quad.point.x += x;
        //         quad.point.y += y;
        //         }
        //     }
        //     return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        //     });
        // };
        // }




        function updateCircles() {
        circles
        // .each(collide(12))
        .attr("fill", function(g) {
            genreColorScale(g.genreCode);
        });
        }



        function createForces() {
            var forceStrength = -.005;
        

            forces = {
            combine:  createCombineForces()
            };

            function createCombineForces() {
                return {
                    x: d3.forceX(-200).strength(forceStrength),
                    y: d3.forceY(-200).strength(forceStrength)
                };
            }
        }

            function createForceSimulation() {
                forceSimulation = d3.forceSimulation()
                .force("x", forces.combine.x)
                .force("y", forces.combine.y)
                .force("collide", d3.forceCollide(forceCollide));
                forceSimulation.nodes(genreCollection)
                .on("tick", function() {
                    circles
                    .attr("cx", function(d) { 
                        debugger;
                        return d.x * 5; })
                    .attr("cy", function(d) { return d.y * 5; })
                });
            }

            function forceCollide(g) {
            return circleRadiusScale(g.Count) + 1;
            };

            // function updateForces(forces) {
            //  forceSimulation
            //     .force("x", forces.x)
            //     .force("y", forces.y)
            //     .force("collide", d3.forceCollide(forceCollide))
            //     .alphaTarget(0.5)
            //     .restart();
            // }

    }   
    createBubbleChart(genreCollection);
</script>