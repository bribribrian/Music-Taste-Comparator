
<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
  <title>
    Music Taste Comparator
  </title>
  <link rel='stylesheet' href='/stylesheets/main_page.css' />
</head>


<body>
    <div class='nav-bar-container'>
        <h1 class='main-title'>Music Taste Comparator</h1>

        <form class='search-form' id="searchForm">
            <div class='search-form-elements'>
                <div>Enter a username</div>
                <input id='searchUser' type='text' value='keenannichols'></input>
                <input type='submit'></input>
            </div>
        </form>
    </div>


    <div class='main-body-container'>
        <div class='track-info-container' id="trackinfo" class="trackinfo"></div>

        
        <div class='canvas' id='canvas'></div>
        <div class='track-info-container2' id='trackinfo2' class='trackinfo2'></div>
    </div>
</body>
<!-- <script src="../API/spotify_api.js"></script> -->
<script>
    document.addEventListener("DOMContentLoaded", () => {
        const seachForm = document.getElementById("searchForm");
        seachForm.addEventListener("submit", handleSubmit);
    });
    
    function handleSubmit (e) {
        e.preventDefault();
        const searchUser = document.getElementById("searchUser");

        console.log(searchUser.value);
        fetchSearchedUser(searchUser.value);
    }

    function fetchSearchedUser(username) {
        const request = new XMLHttpRequest();
        request.open(
        "GET",
        `/searcheduser?username=${username}`,
        true
        );
        request.onload = this.ajaxSuccess.bind(request);
        request.send();
    }

    function ajaxSuccess() {
        if (this.status >= 200 && this.status < 400) {
            const data = JSON.parse(this.response);
            console.log(data);
            let htmlOutput2 = "<div class='top-tracks-title'>Your Friend's Tracks:</div><ul>";
            data.tracks_audiodata.forEach(track => {
                htmlOutput2 += `<li class='track-name'>${track.name}</li>`;
            });
            htmlOutput2 += "</ul>";
            document.getElementById("trackinfo2").innerHTML = htmlOutput2;
            const genre_collection2 = data.genre_collection2;
            document.getElementById('canvas').innerHTML = '';
            Object.values(genre_collection2).forEach(genre_obj => {
                if (genreCollection[genre_obj.genreName]) {
                    genreCollection[genre_obj.genreName].count++;
                } else {
                    genreCollection[genre_obj.genreName] = genre_obj;
                }
            })
            const genreCollectionArray2 = Object.values(genreCollection).map((obj, idx) => {
                obj.genreCode = idx;
                return obj;
            }); 
            createBubbleChart(genreCollectionArray2);

        } else {
        // error
        }

    }

    
    // console.log(track_info);
    const trackAttributes = <%- JSON.stringify(tracks_audiodata) %>;
    const genreCollection = <%- JSON.stringify(genre_collection) %>;
    const genreCollectionArray1 = Object.values(JSON.parse(JSON.stringify(genreCollection))).map((obj, idx) => {
        obj.genreCode = idx;
        return obj;
    }); 
    let htmlOutput = "<div class='top-tracks-title'>Your Top Tracks:</div><ul>";
    // console.log(trackAttributes);
    // console.log(genreCollectionArray1);
    trackAttributes.forEach(trackInfo => {
        htmlOutput += `<li class='track-name'>${trackInfo.name}</li>`;
    });
    htmlOutput += "</ul>";
    // console.log(genreCollection);
    // document.getElementById("sessionData").innerHTML = `Your session data:
    // <br /> ${sessionData}`;
    // document.getElementById("trackinfo").innerHTML = function(trackAttriubutes) {
    //     trackAttributes.forEach(track => {
    //         return <div>track.title</div>
    //     }
    // )};
    
    document.getElementById("trackinfo").innerHTML = htmlOutput;
    //`Your tracks:
    // <br /> 
    // ${trackAttributes[0].title}`
    
    // const circleRadiusScale = d3.scaleSqrt()
    //     .domain(populationExtent)
    //     .range([circleSize.min, circleSize.max]);

    // const forces,
    //   forceSimulation;

    // d3.queue()
    // .defer(d3.csv, "genres")
    // .await(createBubbleChart);

    function createBubbleChart(genres_collection) {
        const counts = [];
        genres_collection.forEach(genre_obj => {
            counts.push(genre_obj.count);
        });

        const countExtent = d3.extent(counts);

        var genreColorScale = d3.scaleOrdinal(d3.schemeCategory10);
            // .domain([0,1,2]);

        var width = 800,
            height = 800;
            // clusterPadding = .5,
            // padding = 1.0;
        var svg,
            circles,
            circleSize = { min: 2, max: 60 };
        var circleRadiusScale = d3.scaleSqrt()
            .domain(countExtent)
            .range([circleSize.min, circleSize.max]);
        var forces,
            forceSimulation;

        // var div = d3.select(".canvas").append("div")
        //     .attr("class", "tooltip")
        //     .style("opacity", 0);

        createSVG();
        createCircles();
        createForces();
        createForceSimulation();
    
        var div = d3.select(".canvas").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        function createSVG() {
        svg = d3.select(".canvas")
        .append("svg")
            .attr("width", width)
            .attr("height", height);
        }

        function createCircles() {
            var formatCount = d3.format(",");
            circles = svg.selectAll("circle")
                .data(genres_collection)
                .enter()
                    .append("circle")
                    .attr("r", function(g) { return circleRadiusScale(g.count); })
                    .style("mix-blend-mode", "multiply")
                    // .style("isolation", "isolate")
                    // .attr("cx", function(d) { 
                    //     debugger;
                    //     return d.count * 2; })
                    // .attr("cy", function(d) { return d.count; })
                    .on("mouseover", handleMouseOver)
                    .on("mouseout", handleMouseOut)
                    // .style("padding", 50);
            updateCircles();

            // function updateGenreInfo(genre) {
            //     var info = "";
            //         if (genre) {
            //             info = [genre.genreName, formatCount(genre.count)].join(": ");
            //         }
            //     d3.select("#genre-info").html(info);
            //     }
            function handleMouseOver(d, i) { 
                d3.select(this)
                .attr('fill', 'blue')
                .style('stroke', 'black')
                .style("opacity", 1)
                div.transition()
                .duration(200)
                .style("opacity", 1);
                div.html(`${d.genreName}: ${d.count}`)
                // .style('mix-blend-mode', 'screen')
                // .style("isolation", "isolate")
                }

                function handleMouseOut(d, i) {
                d3.select(this)
                .attr('fill', genreColorScale(i))
                .style('stroke', 'white')
                .style('mix-blend-mode', 'multiply')
                }

        }

        
        // function collide(alpha) {
        // var quadtree = d3.quadtree(circles);
        // return function(d) {
        //     var r = d.radius + circleSize.max + Math.max(padding, clusterPadding),
        //         nx1 = d.x - r,
        //         nx2 = d.x + r,
        //         ny1 = d.y - r,
        //         ny2 = d.y + r;
        //     quadtree.visit(function(quad, x1, y1, x2, y2) {
        //     if (quad.point && (quad.point !== d)) {
        //         var x = d.x - quad.point.x,
        //             y = d.y - quad.point.y,
        //             l = Math.sqrt(x * x + y * y),
        //             r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
        //         if (l < r) {
        //         l = (l - r) / l * alpha;
        //         d.x -= x *= l;
        //         d.y -= y *= l;
        //         quad.point.x += x;
        //         quad.point.y += y;
        //         }
        //     }
        //     return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        //     });
        // };
        // }




        function updateCircles() {
        svg.selectAll('circle')
        .attr("fill", function(g) {
            return genreColorScale(g.genreCode);
        });
        }



        function createForces() {
            var forceStrength = -.0055;
        

            forces = {
            combine:  createCombineForces()
            };

            function createCombineForces() {
                return {
                    x: d3.forceX(-420).strength(forceStrength),
                    y: d3.forceY(-420).strength(forceStrength)
                };
            }
        }

            function createForceSimulation() {
                forceSimulation = d3.forceSimulation()
                .force("x", forces.combine.x)
                .force("y", forces.combine.y)
                // .force("collide", d3.forceCollide(d => d.radius * 1.2).strength(1))
                forceSimulation.nodes(genres_collection)
                .on("tick", function() {
                    circles
                    .attr("cx", function(d) { return d.x * 2.37; })
                    .attr("cy", function(d) { return d.y * 2.37; })
                });
            }

            // function forceCollide(g) {
            // // return circleRadiusScale(g.Count -5);
            // };

            // function updateForces(forces) {
            //  forceSimulation
            //     .force("x", forces.x)
            //     .force("y", forces.y)
            //     .force("collide", d3.forceCollide(forceCollide))
            //     .alphaTarget(0.5)
            //     .restart();
            // }

    }   
    createBubbleChart(genreCollectionArray1);
</script>